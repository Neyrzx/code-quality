
# Code Quality

#### 1. Как организовать проект на Go, следуя стандартам проектирования и качественного кода?
За основу взял бы **project-layout** из репозитория **golang-standards**. И организовал проект примерно так. Некоторые решения по проекту сильно зависят от предпочтений команды.
```
project/
├── .git/
│  └── hooks/
│    ├── автоматизация контроля качества кода.
│    ├── pre-commit.sh - линтеры, форматтеры кода, unit тесты.
│    ├── pre-push.sh - интеграционные тесты.
│    └── ... и т.п.
├── api/
│  ├── Контракты проекта, могут быть отдельным репозиторием.
│  ├── openapi/
│  │  └── *.yaml
│  └── proto/
│    └── *.proto
├── docs/
│  ├── Документация проекта.
│  └── *.md
├── configs/
│  ├── Вся конфигурация проекта.
│  ├── *.yaml
│  └── *.env
├── deployments/
│  ├── Зависит от инфраструктуры.
│  ├── Также манифесты для локальной разработки или тестирования.
│  ├── Dockerfile
│  ├── compose.yaml
│  └── helm/
│  └── k8s/
│    └── *.yaml
├── cmd/
│  └── app/
│    └── main.go Точка входа в приложение
├── internal/
│  ├── Чистая архитектура, Слоистая, Гексоганальная или DDD.
│  ├── Зависит от команды. Например такая если это микросервис:
│  ├── app/
│  │  └── app.go
│  ├── handler/
│  │  ├── rest/
│  │  │  ├── v1/handler.go
│  │  │  └── api.go
│  │  └── grpc/
│  │    └── handler.go
│  ├── entity/
│  │  └── entity.go
│  ├── errors/
│  │  └── errors.go
│  ├── service/
│  │  ├── checkout/
│  │  │  └── checkout.go
│  │  └── payment/
│  │    └── payment.go
│  └── repository/
│    └── product/
│      ├── postgres/
│      │  └── product.go
│      └── product.go
├── pkg/
│  ├── Для переиспользуемых пакетов в других севисах и т.п.
│  └── Например клиент сгенерированый из openapi или proto контрактов.
├── test/
│  └── Интеграционные, нагрузочные, BDD и т.п.
├── tools/
│  ├── Тулинг нужный проекту, линтеры, форматтеры 
│  ├── Кодогенераторы (openapi, grpc)
│  └── tools.go
├── scipts/
│  └── Скрипты для облегчения читаемости Makefile.
├── .[configs].yaml - файлы конфигурации для тулинга.
├── README.md - документация проекта.
└── Makefile
```
Для статического анализа кода взял бы golangci-lint, для контроля качества кода. Юнит-тесты рядом с тестируемым файлом.

 ---
#### _2. Что такое go fmt и почему его важно использовать для форматирования кода?_
**go fmt** - это стандартный инструмент Go для автоматического форматирования кода в соответствии с официальными стайл гайдом языка. **Единообразие в форматировании кода облегчает его чтение и понимание.**

 ---
#### _3. Как использовать go doc для документирования кода?_
**go doc** - это стандартный инструмент Go для генерации документации из комментариев в коде. Он автоматически создает описание пакетов, функций, типов и методов.

Пример документирования кода для **go doc**.
```go
// important пакет предоставляет важный функционал)
//
// какое-то summary для пакета.
package important

// A очень важный объект, для важных методов.
type A struct{}

// Method выполняет очень важную функцию.
// Если выполнить важную функцию не получилось, то вернёт ошибку.
func (a *A) Method(n int) error {
    ...
}

// B - какое-то осмысленное назначение глобальной переменной.
const B = 1337
```

Использование:

```sh
go doc <имя пакета>
```
```sh
go install golang.org/x/tools/cmd/godoc@latest
godoc -http :18080
```
---

#### 4. Что такое goimports и как он помогает в управлении импортами?
**goimports** - это расширенная версия **go fmt**, которая автоматически управляет импортами в Go. Он добавляет недостающие импорты, удаляет неиспользуемые и сортирует их.

---
#### 5. Как организовать структуру проекта на Go для повышения его читаемости и поддерживаемости?
Всё то, что я описал в первом вопросе. 
Ключевые принципы, которых стоит придерживаться:
* Соблюдение стандартной структуры проекта.
* Разбивать код на слои, и пакеты внутри слоёв.
	* Слой бизнес логики (бизнес логика);
	* Слой контроллеров (транспортный слой);
	* Слой репозиториев (дата слой)
* Писать код, который зависит от интерфейсов, а не конкретных типов (опираться на поведение, а не конкретную реализацию). Чтобы в любой момент, можно было поменять одну реализацию на другую без изменения зависящего от неё кода. Описывать интерфейсы по месту использования.
* Использовать модули (go modules) для управления зависимостями проекта.
* Документировать код, для облегчения его понимания.
* Использовать линтеры и форматеры кода, для соответствия стайл гайду, облегчения код-ревью.

---
#### 6. Как Go Modules упрощают управление зависимостями в проектах?
* Изоляция проекта.
	* Зависимости хранятся локально для каждого проекта.
* Контроль версий зависимостей проекта.
	* Обеспечивает "воспроизводимость" установки зависимостей проекта, за счёт файла go.sum, который хранит хеши всех зависимостей.
	* Все зависимости попадают в файл go.mod. Список зависимостей на виду.
* Автоматическое управление зависимостями.
	* go get - добавление/обновление.
	* go mod tidy - удаление неиспользуемых зависимостей, установка неустановленных.

---
#### 7. Какие инструменты линтинга помогают улучшить качество кода в Go?
Для большинства случаев достаточно использования **golangci-lint**, который 
включает в себя все линтеры, которые могут понадобиться.
Проще перечислить категории линтеров входящих в golangci-lint.
Все они в разной степени помогают улучшить качество кода, решить проблемы 
единого стиля, безопасности (gosec, govulncheck), надежности (errcheck, staticcheck) 
предоставляя возможность настройки линтеров под свои требования.

---
#### 8. Как использовать Makefile для автоматизации сборки и тестирования проектов?

В Makefile-e описать все таргеты, например, для сборки проекта, тестирования,
линтинга. А на CI запускать уже подготовленные команды из Makefile.
Это упрощает процессы на CI. Т.к. программист предоставляет уже готовый набор 
команд, и CI не нужно знать как в проекте запустить тесты, или собрать его.

---
#### 9. Как реализовать архитектуру Clean Architecture в проектах на Go?

Слои архитектуры:
Entities (Бизнес-логика)
Use Cases (Сценарии использования)
Interface Adapters (Контроллеры, шлюзы)
Frameworks & Drivers (Внешние системы, БД, веб-фреймворки)

```
/internal/
├── /entity
├── /usecase
└── /interfaces/
    ├── /controller
    └── /repository
```
В принципе не жестких требований к организации каталогов, это как в команде принято.

Но в любом случае стоит придерживаться след. принципов:
* Разделение на слои (Clean Architecture)
* Четкое разделение ответственности (SRP)
* Внутреннии слои не зависят от внешних
* Зависимости направлены внутрь
* Завязываться на интерфейсы, а не конкретные типы (реализации)


---
#### 10. Какие ошибки часто допускаются при использовании Clean Architecture и как их избегать?

* Смешивание слоёв
* Избыточная сложность, там где это не требуется (небольшой проект, в котором не требуется вся та гибкость чистой архитектуры).
* Недостаточная абстракция, зависимость на конкретные типы и реализации, например, в бизнес-логике завязываемся на конкретную БД.
* Избыточность слоёв.
* Зависимость внешних слоёв от внутренних.


---
#### 11. Как организовать сложные микросервисы, чтобы минимизировать дублирование кода и обеспечить масштабируемость?

* Использование общих библиотек. Код который, дублируется в множестве микросервисах, хорошо выносить в отдельный репозиторий (инфраструктурный) для переиспользования.
* Использование api gateway для централизации запросов, их маршрутизации, кэширования, аутентификации, что уменьшает кодовую базы в самих микросервисах.
* Организация асинхронного взаимодействия (сервисная шина). Взаимодействие через шину (kafka, rabbitmq, nats и т.п...) облегчает масштабирование.
* Контейнеризация и оркестрация. Использовать docker-образы для оркестрации, например, с использованием k8s, swarm. Контейнеризация микросервисов облегает,
развертывание, масштабирование и управление.
* Централизованное управление конфигурациями.


---
#### 12. Как правильно документировать и поддерживать стандарты кода в больших командах?

* Документирование стайл гайдов, стандартов и подходов, архитектуры проекта.
* Документирование на запуск проекта... крч. онбординг.
* Все должны следовать единым стандартам, определенным в проекте.
* Использование автоматизации для проверок кода на соответствие этим стандартам.
* Поддержка документации в актуальном состоянии 😄
* Code-Review + какие-нибудь встречи для ознакомления разработчиков с новым функционалом, требованиями к разработке и качеству и т.д.

---
#### 13. Что такое GOPATH и как он используется в Go для управления пакетами и проектами?

GOPATH - переменная окружения, которая используется Go для организации воркспейса.
По этому пути устанавливаются зависимости проекта.

---
#### 14. Как создать и использовать собственные пакеты в Go?

Пакет - это директория с файлами .go, которые имеют одинаковое имя package в начале.

Пакеты могут быть вложенными.

Использование пакета в коде осуществляется через импорт.
Импортируются, только экспортируемые элементы (все элементы объявленные с большой буквы)

Для публикации пакета, достаточно запушить его в систему контроля версий.

---
#### 15 Что такое структура папок в Go и как она влияет на организацию кода?

Папка в go может быть как пакетом (package), так и модулем (module). Модуль подразумевает наличие файла go.mod в папке.

В go есть общепринятая структура папок, основные папки были перечислены в первом вопросе.

---
#### 16 Как правильно именовать функции, переменные и файлы в Go, следуя соглашениям?

* Выбирать короткие имена для локальных переменных.
* Для глобальных переменных давать более осмысленные имена, описывающих их назначение.
* Использовать camelCase.
* Для функций использовать глаголы, имя должно отражать назначение функции.
* Файлам давать имена в нижнем регистре. Разделать `_` если имя файла состоит из нескольких слов.
* Для файлов с тестами использовать суффикс `_test`.
* Интерфейсы подразумевают поведение, имя должно отражать это поведение.
* Имена для ошибок должны начинаться с префикса `Err`
* Каналы должны заканчиваться суффиксом `Ch`

---
#### 17 Что такое init-функция в Go и когда её следует использовать?

init-функция - это спец. функция, которая выполняется при инициализации пакета
, например, импорте.
Следует использовать для инициализации переменных, конфигураций или регистрации компонентов.

---
#### 18 Какие соглашения существуют для написания тестов в Go?

* Именование тестовых файлов с суффиксом `_test`
* Тестовые файлы находятся в той же директории, что и тестируемый код.
* Именование тестовых функций с префиксом `Test`
* Именование тестовых пакетов с суффиксом `_test`

---
#### 19 Как организовать работу с конфигурационными файлами в Go-проектах?

* Использовать переменные окружения.
* Использовать yaml (json, и т.п.).

Реализация пакета для работы с конфигурацией проекта, валидация параметров.

---
#### 20 Что такое контекст (context) в Go и как его правильно использовать для управления временем выполнения?

Context - структура для управлением исполнением кода, отменой, передачей данных.

* Отмена (WithCancel): Позволяет отменить выполнение операции.
* Тайм-аут (WithTimeout): Устанавливает ограничение по времени выполнения.
* Дедлайн (WithDeadline): Устанавливает конкретное время завершения.
* Передача данных (WithValue): Позволяет передавать данные между горутинами.


```go
func main() {
    ctx := context.Background()

    ctx, cancel := context.WithTimeout(ctx, 15*time.Second)
    defer cancel()

    long_operation(ctx)
}
```